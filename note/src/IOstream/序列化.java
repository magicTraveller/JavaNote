package IOstream;

import java.io.Serializable;

public class 序列化 implements Serializable{
//对象和字节序列（byte）之间的转换 序列化和反序列化
	//需要序列化的对象要implements Serializable 序列化接口 啥方法对象都没有。。。要他干嘛 不明白。。
	//好吧应该仅仅是个限制条件
	//ObjectIn/OutputStream 用writeObject方法 反序列化的话出来的是Object 要强制转换的
	//一些数组可能没放满自己一个一个序列化可能更好一点	
	private transient int  i;//不会进行jvm默认的(或者说批量？)序列化 defautWrite/ReaderObject在readObject里有 可以单独对该元素序列化 writeInt
	
	


	/*
	 * 这个序列化意思是，当你序列化一个文件并且写入的时候，
	 *  在你写入的数据文件中是有实现了序列化接口的那些类的信息。
	 * 这样你反序列化，他们都存在就不会重新创建了。 
	 * 但是如果你父类没有序列化，子类序列化了，当你序列化写的时候，
	 * 父类是没有被写入的，当你反序列化读取的时候，你读取到了子类，
	 *  但是没有发现父类，此时就会去调用父类的构造方法了，此时就有输出了
	 */

	/*
	 * 无论子、父类是否实现序列化接口，创建子类对象时都会递归调用父、子类构造函数
	 * 没有实现序列化接口的父类们不会被序列化到文件
	 * 当父类已经实现 Serializable 接口时，子类不需要重复实现该接口。 注意：若其更高层的某一父类没有实现该接口，则在反序列化时，
	 * 会显示调用其父类的构造函数。 （已实现该接口的类在反序列化是不会显示调用其构造函数）
	 */
	
}
